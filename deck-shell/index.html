<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MicroService OS ‚Äî Deck Shell v1.3 (Live)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; background:#0b1020; color:#e5e7eb; margin:0; padding:20px; }
    h1 { margin-top:0; }
    .toolbar { display:flex; gap:10px; align-items:center; margin:10px 0 20px; }
    .deck { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px,1fr)); gap:16px; }
    .card { background:#111827; border:1px solid #1f2937; border-radius:12px; padding:16px; }
    h2 { margin:0 0 8px; font-size:16px; }
    .metric { font-size:22px; font-weight:bold; margin:6px 0; word-break:break-word; }
    .ok { color:#34d399; } .warn { color:#fbbf24; } .bad { color:#f87171; }
    pre { background:#0a0e1a; padding:10px; border-radius:6px; font-size:12px; overflow:auto; color:#93c5fd; }
    .muted { color:#9ca3af; font-size:12px; }
    .err { color:#f87171; font-size:12px; }
    input, select, button { background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:8px; padding:6px 10px; }
    button { cursor:pointer; }
  </style>
</head>
<body>
  <h1>üìä MicroService OS ‚Äî Deck Shell v1.3</h1>

  <div class="toolbar">
    <label class="muted">Poll (seconds):
      <input id="pollSecs" type="number" min="5" value="30" style="width:70px; margin-left:6px" />
    </label>
    <button id="btnApplyInterval">Apply</button>
    <button id="btnTick">Tick Now</button>
    <span id="lastUpdate" class="muted" style="margin-left:auto">Last update: ‚Äî</span>
  </div>

  <div id="deck" class="deck"></div>

  <!-- Inline SPC (optional). If empty, the shell loads ./spc.json -->
  <script id="spc" type="application/json"></script>

  <script>
  // ========= tiny DOM helpers =========
  const $ = s => document.querySelector(s);
  const asPre = (obj, indent=2) => { const pre=document.createElement('pre'); pre.textContent = typeof obj==='string'?obj:JSON.stringify(obj,null,indent); return pre; };
  const safe = v => (v===undefined||v===null)?'':String(v);

  // ========= minimal functional engine (browser-side) =========
  const deepClone = x => JSON.parse(JSON.stringify(x ?? null));
  function applyRules(data, ruleConfig) {
    let ctx = deepClone(data);
    const rules = (ruleConfig && ruleConfig.rules) || [];
    for (const rule of rules) {
      if (evalCondition(rule.if, ctx)) {
        if (rule.then) {
          for (const [k, expr] of Object.entries(rule.then)) {
            ctx[k] = resolveTemplate(expr, ctx);
          }
        }
      }
    }
    return ctx;
  }
  function evalCondition(cond, context) {
    if (!cond) return true;
    try {
      const ctx = { ...context, data: context }; // alias 'data'
      const fn = new Function(...Object.keys(ctx), `return (${cond})`);
      return !!fn(...Object.values(ctx));
    } catch { return false; }
  }
  function resolveTemplate(tpl, context) {
    if (typeof tpl !== 'string') return tpl;
    const m = tpl.match(/^\{\{\s*(.*?)\s*\}\}$/);
    if (!m) return tpl;
    try {
      const ctx = { ...context, data: context };
      const fn = new Function(...Object.keys(ctx), `return (${m[1]})`);
      return fn(...Object.values(ctx));
    } catch { return tpl; }
  }
  function evaluateExpression(expression, data) {
    try { const fn = new Function('data', `return (${expression})`); return fn(data); } catch { return null; }
  }
  function evaluateThreshold(value, t = {}) {
    if (typeof t.above === 'number' && value >= t.above) return 'critical';
    if (typeof t.below === 'number' && value <= t.below) return 'critical';
    if (typeof t.warnAbove === 'number' && value >= t.warnAbove) return 'warning';
    if (typeof t.warnBelow === 'number' && value <= t.warnBelow) return 'warning';
    if (typeof t.critical === 'number' && value >= t.critical) return 'critical';
    if (typeof t.warning === 'number' && value >= t.warning) return 'warning';
    return 'ok';
  }

  // ========= deck runtime =========
  let SPC = null;
  let pollTimer = null;

  async function bootSPC() {
    // 1) inline SPC first
    const inline = $('#spc');
    if (inline && inline.textContent.trim()) {
      try { SPC = JSON.parse(inline.textContent); } catch(e){ console.error('Inline SPC parse error', e); }
    }
    // 2) fallback to ./spc.json
    if (!SPC) {
      try { const r = await fetch('spc.json', {cache:'no-store'}); if (r.ok) SPC = await r.json(); } catch {}
    }
    if (!SPC) { $('#deck').innerHTML = "<p class='err'>‚ö†Ô∏è No SPC configuration found.</p>"; return; }

    // First render
    renderDeck(SPC);

    // Start polling
    startPolling();
    // Buttons
    $('#btnApplyInterval').onclick = () => startPolling();
    $('#btnTick').onclick = () => tickOnce();
  }

  function startPolling() {
    const secs = Math.max(5, Number($('#pollSecs').value) || 30);
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(tickOnce, secs * 1000);
    // run immediately on change
    tickOnce();
  }

  async function tickOnce() {
    if (!SPC) return;

    // 1) Update connectors (async fetch)
    await updateConnectors(SPC);

    // 2) Recompute processors (pure functions on state)
    runProcessors(SPC);

    // 3) Recompute monitors
    runMonitors(SPC);

    // 4) Re-render
    renderDeck(SPC);
    $('#lastUpdate').textContent = 'Last update: ' + new Date().toLocaleTimeString();
  }

  async function updateConnectors(spc) {
    const services = spc.services || {};
    const state = spc.state = spc.state || {};
    const tasks = [];

    Object.entries(services).forEach(([id, svc]) => {
      if (svc.type !== 'connector' || !svc.spec || !svc.spec.url) return;

      const { url, method='GET', headers={}, rules } = svc.spec;
      const outKey = svc.spec.outputKey || `${id}_data`;

      const t = fetch(url, { method, headers }).then(async r => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const data = await r.json();
        // optional: store raw snapshot
        state[outKey + '_raw'] = data;

        // rules handling: default "merge" (like we recommended)
        let final = data;
        if (rules) {
          const processed = applyRules(data, rules);
          const mode = rules.mode || 'merge'; // merge | replace | dual
          if (mode === 'replace') final = processed;
          else if (mode === 'dual') { state[outKey + '_processed'] = processed; final = data; }
          else final = { ...data, ...processed };
        }
        state[outKey] = final;
      }).catch(err => {
        // keep previous state; annotate an error flag for UI if needed
        state[outKey + '_error'] = String(err.message || err);
      });

      tasks.push(t);
    });

    // Await all connector fetches
    if (tasks.length) {
      try { await Promise.allSettled(tasks); } catch {}
    }
  }

  function runProcessors(spc) {
    const services = spc.services || {};
    const state = spc.state = spc.state || {};

    Object.entries(services).forEach(([id, svc]) => {
      if (svc.type !== 'processor' || !svc.spec) return;

      const { inputKey, outputKey, transform } = svc.spec;
      const inp = state[inputKey];
      if (inp === undefined) return; // no input yet

      let result = inp;
      if (transform) result = applyRules(inp, { rules: transform });
      state[outputKey || `${id}_out`] = result;
    });
  }

  function runMonitors(spc) {
    const services = spc.services || {};
    const state = spc.state = spc.state || {};

    Object.entries(services).forEach(([id, svc]) => {
      if (svc.type !== 'monitor' || !svc.spec) return;

      const { checks = [], thresholds = {} } = svc.spec;
      const results = {};
      for (const check of checks) {
        const data = state[check.dataKey];
        if (data === undefined) continue;
        const value = evaluateExpression(check.expression, data);
        const th = thresholds[check.name] || thresholds || {};
        results[check.name] = { value, status: evaluateThreshold(value, th) };
      }
      state[`${id}_monitoring`] = results;
    });
  }

  // ========= renderer =========
  function renderDeck(spc) {
    const deck = $('#deck'); deck.innerHTML = '';
    const services = spc.services || {};
    const state = spc.state || {};

    Object.entries(services).forEach(([id, svc]) => {
      const card = document.createElement('div'); card.className = 'card';
      try {
        const title = safe(svc.title || id);
        const type = safe(svc.type || 'unknown');
        const spec = svc.spec || {};
        const header = document.createElement('div');
        header.innerHTML = `<h2>${title}</h2><div class="muted">Type: ${type}</div>`;
        card.appendChild(header);

        if (type === 'connector') {
          const outKey = spec.outputKey || `${id}_data`;
          const data = state[outKey];
          const info = document.createElement('div');
          info.innerHTML = `<div><strong>Endpoint:</strong> ${safe(spec.url) || '‚Äî'}</div><div><strong>Output Key:</strong> ${safe(outKey)}</div>`;
          card.appendChild(info);
          card.appendChild(asPre(data ?? 'No data'));

        } else if (type === 'processor') {
          const inpKey = spec.inputKey || '‚Äî';
          const outKey = spec.outputKey || `${id}_out`;
          const out = state[outKey];
          const info = document.createElement('div');
          info.innerHTML = `<div><strong>Input:</strong> ${safe(inpKey)}</div><div><strong>Output:</strong> ${safe(outKey)}</div>`;
          card.appendChild(info);
          card.appendChild(asPre(out ?? 'No output yet'));

        } else if (type === 'monitor') {
          const mon = state[`${id}_monitoring`];
          if (mon && typeof mon === 'object' && Object.keys(mon).length) {
            Object.entries(mon).forEach(([check, result]) => {
              const val = result?.value;
              const status = result?.status || 'unknown';
              const color = status === 'ok' ? 'ok' : status === 'warning' ? 'warn' : 'bad';
              const row = document.createElement('div');
              row.innerHTML = `<div><strong>${safe(check)}</strong>: <span class="metric ${color}">${safe(val)}</span> [${safe(status)}]</div>`;
              card.appendChild(row);
            });
          } else {
            card.appendChild(asPre('No monitoring data'));
          }

        } else if (type === 'interface') {
          const outKey = spec.outputKey || `${id}_result`;
          const iface = state[outKey];
          const info = document.createElement('div');
          info.innerHTML = `<div><strong>Output Key:</strong> ${safe(outKey)}</div>`;
          card.appendChild(info);
          card.appendChild(asPre(iface ?? 'Interface idle'));

        } else {
          card.appendChild(asPre(svc));
        }
      } catch (e) {
        const errBox = document.createElement('div');
        errBox.innerHTML = `<div class="err">Render error: ${safe(e.message)}</div>`;
        card.appendChild(errBox);
      }
      deck.appendChild(card);
    });

    // Raw state viewer
    const raw = document.createElement('div');
    raw.className = 'card';
    raw.innerHTML = `<h2>üì¶ Raw State</h2>`;
    raw.appendChild(asPre(state));
    deck.appendChild(raw);
  }

  // ========= boot =========
  document.addEventListener('DOMContentLoaded', bootSPC);
  </script>
</body>
</html>

