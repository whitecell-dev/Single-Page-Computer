// Compiles SPC to JavaScript module with optimized execution

exports.compile = function(spc) {
  // For v0, we're generating optimized JavaScript that could later compile to WASM
  // This proves the concept without the complexity of actual WASM generation
  
  return `#!/usr/bin/env node
// Generated by KERN compiler v0.1
// This module can be compiled to WASM in future versions

const fetch = ${typeof fetch !== 'undefined' ? 'fetch' : "require('node-fetch')"};

const config = ${JSON.stringify(spc, null, 2)};

class CompiledSPC {
  constructor() {
    this.state = ${JSON.stringify(spc.state || {})};
    this.services = config.services;
  }

  async run() {
    const startTime = Date.now();
    
    // Optimized execution order
    ${generateOptimizedExecution(spc)}
    
    const endTime = Date.now();
    console.error(\`Execution time: \${endTime - startTime}ms\`);
    
    return this.state;
  }
  
  // Helper functions
  evaluateCondition(condition, context) {
    if (!condition || condition === true) return true;
    return new Function('data', \`return \${condition}\`)(context);
  }
  
  resolveTemplate(template, context) {
    if (typeof template !== 'string') return template;
    const match = template.match(/^\\{\\{\\s*(.*?)\\s*\\}\\}$/);
    if (!match) return template;
    return new Function('data', \`return \${match[1]}\`)(context);
  }
}

// Export for use as module
if (typeof module !== 'undefined') {
  module.exports = CompiledSPC;
}

// Run if called directly
if (require.main === module) {
  const app = new CompiledSPC();
  app.run().then(state => {
    console.log(JSON.stringify(state, null, 2));
  }).catch(err => {
    console.error('Error:', err);
    process.exit(1);
  });
}
`;
};

function generateOptimizedExecution(spc) {
  const services = spc.services || {};
  const code = [];
  
  // Generate optimized code for each service
  Object.entries(services).forEach(([id, service]) => {
    if (service.type === 'connector') {
      code.push(`
    // Connector: ${id}
    try {
      const ${id}_response = await fetch('${service.spec.url}');
      const ${id}_data = await ${id}_response.json();
      this.state['${service.spec.outputKey || id + '_data'}'] = ${id}_data;
    } catch (e) {
      this.state['${id}_error'] = e.message;
    }`);
    }
    
    if (service.type === 'processor' && service.spec?.inputKey) {
      code.push(`
    // Processor: ${id}
    const ${id}_input = this.state['${service.spec.inputKey}'];
    if (${id}_input) {
      let ${id}_result = ${id}_input;
      ${generateTransforms(service.spec.transform, id)}
      this.state['${service.spec.outputKey}'] = ${id}_result;
    }`);
    }
  });
  
  return code.join('\n');
}

function generateTransforms(transforms, prefix) {
  if (!transforms) return '';
  
  return transforms.map((t, i) => `
      // Transform ${i}
      if (this.evaluateCondition(\`${t.if}\`, ${prefix}_result)) {
        ${Object.entries(t.then || {}).map(([key, expr]) => 
          `${prefix}_result['${key}'] = this.resolveTemplate(\`${expr}\`, ${prefix}_result);`
        ).join('\n        ')}
      }`).join('');
}
